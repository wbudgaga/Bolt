
package mr.communication.handlers;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.channels.SelectionKey;
import java.nio.channels.SocketChannel;
import java.util.ArrayList;

import mr.communication.io.ProtocolDecoder;
import mr.communication.io.ReadWriteSelectorHandler;
import mr.communication.io.SelectorThread;
import mr.dht.peer2peernetwork.handlers.LocalMessageHandler;
import mr.dht.peer2peernetwork.nodes.RemotePeer;
import mr.dht.peer2peernetwork.nodes.Setting;
import mr.dht.peer2peernetwork.wireformates.Message;
import mr.dht.peer2peernetwork.wireformates.MessageFactory;
import mr.resourcemanagement.execution.mrtasks.management.JobTasksManager;


/**
 * Uses non-blocking operations to read and write from a socket. Internally,
 * this class uses a selector to receive read and write events from the
 * underlying socket.  
 *  
 * Methods on this class should be called only by the selector's thread 
 * (including the constructor). If necessary, use Selector.invokeLater() 
 * to dispatch a invocation to the selector's thread.
 */
final public class PacketChannel implements ReadWriteSelectorHandler {
  /** The associated selector. */
  protected final SelectorThread selector;
  /** The socket where read and write operations are performed. */
  private final SocketChannel sc;
  /** Used for reading from the socket. */
  private ByteBuffer inBuffer;
  /**
   * The buffer with the packet currently being sent. 
   * This class can only send one packet at a time, there are no
   * queueing mechanisms.
   */
  private ByteBuffer outBuffer 			= null;
  private volatile RemotePeer remotePeer 	= null;
  /**
   * Used to convert raw bytes into packets. 
   * (Strategy design pattern)
   */
  private final ProtocolDecoder protocolDecoder;

  /**
   * Object interested in the events generated by this class.
   * It is notified whenever an error occurs or a packet is read. 
   */
  private final LocalMessageHandler listener;
	
  private final Object 	LOCK 	 	= new Object();

  
  /**
   * Creates and initializes a new instance. Read interest is enabled
   * by the constructor, so callers should be ready to star receiving
   * packets.
   * 
   * @param socketChannel Socket to be wrapped.
   * @param selector Selector to be used for managing IO events.
   * @param listener Object to receive the callbacks.
   * @param protocolDecoder Decoder for reassembling the packets.
   * @throws IOException
   */
  public PacketChannel(SocketChannel socketChannel, SelectorThread selector, ProtocolDecoder protocolDecoder, LocalMessageHandler listener) throws IOException {
	  this.selector 		= selector;
	  this.protocolDecoder 	= protocolDecoder;
	  this.sc 				= socketChannel;
	  this.sc.socket().setReceiveBufferSize(Setting.RECEIVEBUFF_SIZE);
	  this.sc.socket().setSendBufferSize(Setting.SENDBUFF_SIZE);
	  this.listener 		= listener;
	  inBuffer = ByteBuffer.allocateDirect(sc.socket().getReceiveBufferSize());
	  inBuffer.position(inBuffer.capacity());
	   //   inBuffer.flip();
	  // Registers with read interest.
	  selector.registerChannelNow(sc, SelectionKey.OP_READ,  this);
  }
  
  public RemotePeer getRemotePeer(){
	  return remotePeer;
  }
  public boolean setRemotePeer(RemotePeer rPeer){
	  if (remotePeer == null ){
		  remotePeer = rPeer;
		return true;
	  }
	  return false;
  }
  /**
   * Activates reading from the socket. This method is non-blocking. 
   */
  public synchronized void resumeReading() throws IOException {
    processInBuffer();
  }
  
  public void close() {
    try {
      sc.close();
    } catch (IOException e) { }
  }
  
  
  public synchronized void handleRead() {
	  try {      
		  inBuffer.clear();
		  int readBytes = sc.read(inBuffer);     
		  if (readBytes == -1) {
               close();
               listener.socketDisconnected(this);
               return;
		  }      
		  if (readBytes == 0) {        
			  reactivateReading();
			  return;
		  }    
		  // There is some data in the buffer. Processes it.
		  inBuffer.flip();
		  processInBuffer();
	  } catch (IOException ex) {
		  listener.socketException(this, ex);
		  close();
	  }
  }

  /**
   * Processes the internal buffer, converting it into packets if enough
   * data is available.
   */
  private synchronized void processInBuffer() throws IOException {    
	  //Here should handle the situation where only a portion of the message has been received  
    ArrayList<Message> msgs = new ArrayList<Message>();
    
    if (inBuffer.hasRemaining()){
    	msgs = protocolDecoder.decode(inBuffer);

    	if (!msgs.isEmpty()) {      
    	   	for (Message msg:msgs){
        		listener.packetArrived(this, msg);//======================>>listener.handle(msg);
        	}
    	}
    	reactivateReading();	
    }
  }

  /**
   * Disable interest in reading.
   * @throws IOException 
   */
  public void disableReading() throws IOException {
    selector.removeChannelInterestNow(sc, SelectionKey.OP_READ);    
  }
  
  private void reactivateReading() throws IOException {
	  selector.addChannelInterestNow(sc, SelectionKey.OP_READ);
  }
  
  /**
   * Sends a packet using non-blocking writes. One packet cannot be sent 
   * before the previous one has been dispatched. The caller must ensure 
   * this. 
   * 
   * This class keeps a reference to buffer given as argument while sending
   * it. So it is important not to change this buffer after calling this 
   * method.  
   * 
   * @param packet The packet to be sent. 
   */
  public void sendPacket(ByteBuffer packet) {
    // keeps a reference to the packet. In production code this should copy
    // the contents of the buffer.
	  synchronized (LOCK) {
		    outBuffer = packet;
		    handleWrite();		
	}
  }

  /**
   * Activates interest in writing.
   * 
   * @throws IOException
   */
  public void requestWrite() throws IOException {
    selector.addChannelInterestNow(sc, SelectionKey.OP_WRITE);
  }
  
  /**
   * Writes to the underlying channel. Non-blocking. This method is called
   * only from sendPacket() and from the SelectorThread class.
   */
  public  void handleWrite() {    
	  try {
		  while(outBuffer.hasRemaining()){
			  sc.write(outBuffer);
		  }
		  outBuffer.clear(); //outBuffer;
	      listener.packetSent(this, null);
	      
	  } catch (IOException ioe) {
	      close();
	      listener.socketException(this, ioe);
	  }
	  
  }
  
  public SocketChannel getSocketChannel() {
    return sc;
  }
  
  public String toString() {  
    return Integer.toString(sc.socket().getLocalPort());
  }
}
